# 16. 构件设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 构件设计文档 |
| 版本 | v1.0 |
| 创建日期 | 2025-11-18 |
| 作者 | 系统架构团队 |
| 适用范围 | UC9创建订单、UC10订单支付 |

---

## 1. 构件设计概述

### 1.1 设计目的

本文档详细描述了订单支付系统中三个核心构件的设计：
- **订单构件（Order Component）**：负责订单的创建、查询、更新和取消
- **支付构件（Payment Component）**：负责支付订单的创建、支付处理和回调处理
- **库存构件（Inventory Component）**：负责库存的校验、锁定、扣减和释放

### 1.2 设计内容

每个构件的设计包括：
1. **文字描述**：构件的职责、功能、依赖关系
2. **构件内部类图**：展示构件内部的类结构和关系
3. **构件活动图**：展示构件的处理流程（替代伪代码）
4. **接口详细描述**：详细描述构件提供的所有接口

### 1.3 构件架构图

![构件架构图](out/类图UML/OrderAndPayment_ComponentDiagram/订单构件与支付构件架构图.png)

---

## 2. 订单构件设计

### 2.1 订单构件文字描述

#### 2.1.1 构件职责

订单构件（Order Component）是订单管理的核心构件，负责处理订单的完整生命周期管理。

**主要职责**：
1. **订单创建**：接收用户的下单请求，创建订单和订单明细
2. **库存校验与锁定**：调用库存构件校验库存并预扣库存
3. **订单查询**：提供订单详情查询、订单列表查询功能
4. **订单状态管理**：管理订单状态流转（待支付→待发货→已发货→已完成）
5. **订单取消**：处理订单取消，释放已锁定的库存
6. **支付成功处理**：接收支付成功消息，更新订单状态，扣减库存

#### 2.1.2 构件功能

**核心功能**：
- **UC9创建订单**：
  - 获取购物车商品信息
  - 校验商品库存
  - 计算订单金额
  - 预扣库存（乐观锁）
  - 创建订单和订单明细
  - 设置订单超时时间（30分钟）

- **订单状态管理**：
  - PENDING_PAYMENT（待支付）
  - PENDING_SHIPMENT（待发货）
  - SHIPPED（已发货）
  - COMPLETED（已完成）
  - CANCELLED（已取消）

- **订单超时处理**：
  - 定时任务扫描过期未支付订单
  - 自动取消订单
  - 释放锁定的库存

#### 2.1.3 构件依赖

**提供接口**：
- `POST /orders` - 创建订单
- `GET /orders/{orderNumber}` - 查询订单详情
- `PUT /orders/{orderNumber}/cancel` - 取消订单
- `OrderService.createOrder()` - 创建订单业务逻辑
- `OrderService.handlePaymentSuccess()` - 处理支付成功消息

**需求接口**：
- `InventoryService.batchCheckStock()` - 批量校验库存
- `InventoryService.lockStock()` - 锁定库存
- `CartService.getCartItems()` - 获取购物车商品
- `ProductService.getProductDetails()` - 获取商品详情
- `UserService.getUserAddresses()` - 获取用户地址
- `RabbitMQ.consume()` - 消费支付成功消息

#### 2.1.4 构件约束

**性能约束**：
- 订单创建响应时间 < 1秒（P95）
- 支持并发创建订单 QPS ≥ 1000
- 订单查询响应时间 < 200ms（P95）

**业务约束**：
- 订单超时时间：30分钟
- 订单号生成规则：ORD + 年月日 + 6位序列号
- 订单金额精度：保留2位小数
- 库存锁定失败时回滚订单创建

**技术约束**：
- 使用分布式事务（Seata）保证订单和库存的一致性
- 使用乐观锁更新库存，避免超卖
- 使用消息队列异步处理支付成功事件

### 2.2 订单构件内部类图

![订单构件内部类图](out/类图UML/OrderComponent_ClassDiagram/OrderComponent_ClassDiagram.png)

> **说明**：订单构件采用分层架构设计，包含表示层（OrderController）、业务逻辑层（OrderService）、领域层（Order、OrderItem）、数据访问层（OrderRepository）以及外部服务接口和消息队列。

### 2.3 订单构件活动图

#### 2.3.1 创建订单活动图

![创建订单活动图](out/类图UML/OrderComponent_CreateOrder_Activity/OrderComponent_CreateOrder_Activity.png)

> **说明**：创建订单活动图展示了从接收请求、验证参数、校验库存、锁定库存、创建订单到返回结果的完整流程，包含异常处理和分布式事务管理。

#### 2.3.2 处理支付成功活动图

![处理支付成功活动图](out/类图UML/OrderComponent_HandlePaymentSuccess_Activity/OrderComponent_HandlePaymentSuccess_Activity.png)

> **说明**：处理支付成功活动图展示了从RabbitMQ接收支付成功消息、更新订单状态、扣减库存、清空购物车到发送通知的完整流程，包含幂等性处理。

### 2.4 订单构件接口详细描述

#### 2.4.1 表示层接口（OrderController）

##### 接口1：创建订单

**接口名称**：`createOrder`

**接口类型**：REST API

**HTTP方法**：POST

**请求路径**：`/api/v1/orders`

**接口描述**：接收用户的下单请求，创建订单并返回订单信息

**请求参数**：

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|-------|------|------|------|------|
| userId | Long | 是 | 用户ID | 1001 |
| cartItemIds | List<Long> | 是 | 购物车项ID列表 | [1, 2, 3] |
| addressId | Long | 是 | 收货地址ID | 1 |
| remark | String | 否 | 订单备注 | "请尽快发货" |

**请求示例**：

```json
POST /api/v1/orders
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "userId": 1001,
  "cartItemIds": [1, 2],
  "addressId": 1,
  "remark": "请尽快发货"
}
```

**响应参数**：

| 参数名 | 类型 | 说明 | 示例 |
|-------|------|------|------|
| code | Integer | 响应码 | 200 |
| message | String | 响应消息 | "订单创建成功" |
| data | Object | 订单数据 | {...} |
| data.orderNumber | String | 订单号 | "ORD20251118001" |
| data.totalAmount | BigDecimal | 订单总金额 | 707.00 |
| data.createTime | String | 创建时间 | "2025-11-18T14:30:00" |
| data.expireTime | String | 过期时间 | "2025-11-18T15:00:00" |
| data.status | String | 订单状态 | "PENDING_PAYMENT" |

**响应示例**：

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "code": 200,
  "message": "订单创建成功",
  "data": {
    "orderNumber": "ORD20251118001",
    "totalAmount": 707.00,
    "createTime": "2025-11-18T14:30:00",
    "expireTime": "2025-11-18T15:00:00",
    "status": "PENDING_PAYMENT"
  },
  "timestamp": 1700294400000
}
```

**异常响应**：

| HTTP状态码 | 错误码 | 错误消息 | 说明 |
|-----------|-------|---------|------|
| 400 | 400 | "参数验证失败" | 请求参数不合法 |
| 400 | 4001 | "库存不足" | 商品库存不足 |
| 500 | 5001 | "库存锁定失败" | 库存锁定失败 |
| 500 | 500 | "系统内部错误" | 系统异常 |

**接口约束**：
- 需要用户登录（JWT Token验证）
- 购物车项必须属于当前用户
- 收货地址必须属于当前用户
- 订单金额必须大于0
- 同一用户同时只能创建一个订单（防止重复提交）

**处理流程**：
1. 验证JWT Token，获取用户信息
2. 验证请求参数（userId、cartItemIds、addressId）
3. 调用OrderService.createOrder()创建订单
4. 返回订单创建结果

---

##### 接口2：查询订单详情

**接口名称**：`getOrderDetail`

**接口类型**：REST API

**HTTP方法**：GET

**请求路径**：`/api/v1/orders/{orderNumber}`

**接口描述**：根据订单号查询订单详情

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|-------|------|------|------|------|
| orderNumber | String | 是 | 订单号 | "ORD20251118001" |

**请求示例**：

```
GET /api/v1/orders/ORD20251118001
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**响应参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| code | Integer | 响应码 |
| message | String | 响应消息 |
| data | Object | 订单详情 |
| data.orderNumber | String | 订单号 |
| data.userId | Long | 用户ID |
| data.totalAmount | BigDecimal | 订单总金额 |
| data.status | String | 订单状态 |
| data.createTime | String | 创建时间 |
| data.payTime | String | 支付时间 |
| data.expireTime | String | 过期时间 |
| data.shippingAddress | Object | 收货地址 |
| data.items | Array | 订单明细列表 |

**响应示例**：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "orderNumber": "ORD20251118001",
    "userId": 1001,
    "totalAmount": 707.00,
    "status": "PENDING_PAYMENT",
    "createTime": "2025-11-18T14:30:00",
    "payTime": null,
    "expireTime": "2025-11-18T15:00:00",
    "shippingAddress": {
      "receiverName": "张三",
      "receiverPhone": "13812341234",
      "province": "北京市",
      "city": "北京市",
      "district": "朝阳区",
      "detailAddress": "xxx街道xxx号"
    },
    "items": [
      {
        "productId": 10001,
        "productName": "高性能笔记本电脑",
        "price": 299.00,
        "quantity": 1,
        "subtotal": 299.00
      },
      {
        "productId": 10002,
        "productName": "无线蓝牙耳机",
        "price": 199.00,
        "quantity": 2,
        "subtotal": 398.00
      }
    ]
  }
}
```

**异常响应**：

| HTTP状态码 | 错误码 | 错误消息 | 说明 |
|-----------|-------|---------|------|
| 404 | 404 | "订单不存在" | 订单号不存在 |
| 403 | 403 | "无权访问该订单" | 订单不属于当前用户 |

---

##### 接口3：取消订单

**接口名称**：`cancelOrder`

**接口类型**：REST API

**HTTP方法**：PUT

**请求路径**：`/api/v1/orders/{orderNumber}/cancel`

**接口描述**：取消订单并释放库存

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|-------|------|------|------|------|
| orderNumber | String | 是 | 订单号 | "ORD20251118001" |

**请求示例**：

```
PUT /api/v1/orders/ORD20251118001/cancel
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**响应示例**：

```json
{
  "code": 200,
  "message": "订单取消成功",
  "data": null
}
```

**异常响应**：

| HTTP状态码 | 错误码 | 错误消息 | 说明 |
|-----------|-------|---------|------|
| 404 | 404 | "订单不存在" | 订单号不存在 |
| 400 | 4002 | "订单状态不允许取消" | 订单已支付或已完成 |

**接口约束**：
- 只能取消待支付状态的订单
- 取消订单后自动释放锁定的库存

---

#### 2.4.2 业务逻辑层接口（OrderService）

##### 接口1：创建订单

**接口名称**：`createOrder`

**接口签名**：

```java
CreateOrderResponse createOrder(CreateOrderRequest request);
```

**接口描述**：创建订单的核心业务逻辑

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| request | CreateOrderRequest | 创建订单请求对象 |
| request.userId | Long | 用户ID |
| request.cartItemIds | List<Long> | 购物车项ID列表 |
| request.addressId | Long | 收货地址ID |
| request.remark | String | 订单备注 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| response | CreateOrderResponse | 订单创建结果 |
| response.orderNumber | String | 订单号 |
| response.totalAmount | BigDecimal | 订单总金额 |
| response.createTime | LocalDateTime | 创建时间 |
| response.expireTime | LocalDateTime | 过期时间 |
| response.status | String | 订单状态 |

**异常**：

| 异常类型 | 说明 | 处理方式 |
|---------|------|---------|
| InsufficientStockException | 库存不足 | 返回400错误 |
| StockLockFailedException | 库存锁定失败 | 返回500错误，回滚订单 |
| CartItemNotFoundException | 购物车项不存在 | 返回404错误 |
| AddressNotFoundException | 收货地址不存在 | 返回404错误 |

**处理流程**：

1. **获取购物车商品信息**
   - 调用CartService.getCartItems()获取购物车商品
   - 验证购物车项是否存在
   - 验证购物车项是否属于当前用户

2. **获取商品详情**
   - 调用ProductService.getProductDetails()获取商品详情
   - 验证商品是否存在
   - 验证商品是否上架

3. **校验库存**
   - 调用InventoryService.batchCheckStock()批量校验库存
   - 如果库存不足，抛出InsufficientStockException

4. **创建订单实体**
   - 生成订单号（ORD + 年月日 + 6位序列号）
   - 设置订单状态为PENDING_PAYMENT
   - 设置订单超时时间（当前时间 + 30分钟）
   - 获取收货地址信息

5. **创建订单明细**
   - 遍历购物车项，创建OrderItem
   - 设置商品ID、商品名称、价格、数量

6. **计算订单金额**
   - 计算商品总额
   - 计算运费（满99免运费，否则10元）
   - 计算应付总额

7. **预扣库存（分布式事务）**
   - 开启Seata分布式事务
   - 调用InventoryService.lockStock()锁定库存
   - 使用乐观锁更新库存（available_stock -= quantity, locked_stock += quantity）
   - 如果锁定失败，回滚订单创建，抛出StockLockFailedException

8. **保存订单到数据库**
   - 保存Order实体到orders表
   - 保存OrderItem列表到order_items表

9. **返回订单创建结果**
   - 封装CreateOrderResponse
   - 返回订单号、订单金额、创建时间、过期时间

**事务管理**：
- 使用@Transactional注解开启本地事务
- 使用@GlobalTransactional注解开启Seata分布式事务
- 事务隔离级别：READ_COMMITTED
- 事务传播行为：REQUIRED

**性能优化**：
- 批量查询商品详情，减少数据库查询次数
- 使用Redis缓存商品信息，减少数据库压力
- 异步清空购物车，提高响应速度

---

##### 接口2：查询订单详情

**接口名称**：`getOrderDetail`

**接口签名**：

```java
OrderDetailResponse getOrderDetail(String orderNumber);
```

**接口描述**：根据订单号查询订单详情

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| response | OrderDetailResponse | 订单详情 |

**异常**：

| 异常类型 | 说明 |
|---------|------|
| OrderNotFoundException | 订单不存在 |

**处理流程**：
1. 调用OrderRepository.findByOrderNumber()查询订单
2. 如果订单不存在，抛出OrderNotFoundException
3. 查询订单明细列表
4. 查询收货地址信息
5. 封装OrderDetailResponse并返回

---

##### 接口3：更新订单状态

**接口名称**：`updateOrderStatus`

**接口签名**：

```java
void updateOrderStatus(String orderNumber, OrderStatus status);
```

**接口描述**：更新订单状态

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |
| status | OrderStatus | 新状态 |

**处理流程**：
1. 查询订单
2. 验证状态流转是否合法
3. 更新订单状态
4. 保存到数据库

---

##### 接口4：取消订单

**接口名称**：`cancelOrder`

**接口签名**：

```java
void cancelOrder(String orderNumber);
```

**接口描述**：取消订单并释放库存

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |

**处理流程**：
1. 查询订单
2. 验证订单状态（只能取消待支付订单）
3. 更新订单状态为CANCELLED
4. 调用InventoryService.releaseStock()释放库存
5. 保存到数据库

---

##### 接口5：处理支付成功消息

**接口名称**：`handlePaymentSuccess`

**接口签名**：

```java
void handlePaymentSuccess(PaymentSuccessMessage message);
```

**接口描述**：处理支付成功消息，更新订单状态，扣减库存

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| message | PaymentSuccessMessage | 支付成功消息 |
| message.paymentNumber | String | 支付流水号 |
| message.orderNumber | String | 订单号 |
| message.payTime | LocalDateTime | 支付时间 |

**处理流程**：
1. 根据订单号查询订单
2. 验证订单状态（必须是待支付状态）
3. 更新订单状态为PENDING_SHIPMENT
4. 设置支付时间
5. 调用InventoryService.deductStock()扣减库存
6. 调用CartService.clearPaidItems()清空购物车
7. 保存到数据库
8. 发送订单状态变更通知

---

#### 2.4.3 数据访问层接口（OrderRepository）

##### 接口1：保存订单

**接口名称**：`save`

**接口签名**：

```java
Order save(Order order);
```

**接口描述**：保存订单到数据库

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| order | Order | 订单实体 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| order | Order | 保存后的订单实体（包含自增ID） |

**SQL语句**：

```sql
INSERT INTO orders (
    order_number, user_id, total_amount, status, 
    create_time, expire_time, receiver_name, receiver_phone,
    province, city, district, detail_address, remark
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

INSERT INTO order_items (
    order_id, product_id, product_name, price, quantity, subtotal
) VALUES (?, ?, ?, ?, ?, ?);
```

---

##### 接口2：根据订单号查询订单

**接口名称**：`findByOrderNumber`

**接口签名**：

```java
Order findByOrderNumber(String orderNumber);
```

**接口描述**：根据订单号查询订单

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| order | Order | 订单实体（如果不存在返回null） |

**SQL语句**：

```sql
SELECT * FROM orders WHERE order_number = ?;
```

**索引**：uk_order_number（唯一索引）

---

##### 接口3：根据用户ID查询订单列表

**接口名称**：`findByUserId`

**接口签名**：

```java
Page<Order> findByUserId(Long userId, Page<Order> page);
```

**接口描述**：分页查询用户的订单列表

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| userId | Long | 用户ID |
| page | Page<Order> | 分页参数 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| page | Page<Order> | 订单分页结果 |

**SQL语句**：

```sql
SELECT * FROM orders 
WHERE user_id = ? 
ORDER BY create_time DESC 
LIMIT ?, ?;
```

**索引**：idx_user_id

---

##### 接口4：查询过期未支付订单

**接口名称**：`findExpiredOrders`

**接口签名**：

```java
List<Order> findExpiredOrders(LocalDateTime expireTime);
```

**接口描述**：查询过期未支付的订单

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| expireTime | LocalDateTime | 过期时间 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orders | List<Order> | 过期订单列表 |

**SQL语句**：

```sql
SELECT * FROM orders 
WHERE status = 'PENDING_PAYMENT' 
AND expire_time < ? 
LIMIT 1000;
```

**索引**：idx_status, idx_expire_time

---

## 3. 支付构件设计

### 3.1 支付构件文字描述

#### 3.1.1 构件职责

支付构件（Payment Component）是支付管理的核心构件，负责处理支付订单的创建、支付处理和回调处理。

**主要职责**：
1. **支付订单创建**：根据订单信息创建支付订单
2. **第三方支付调用**：调用支付宝、微信等第三方支付网关
3. **支付回调处理**：处理第三方支付的异步回调通知
4. **支付状态管理**：管理支付订单状态（待支付→支付成功/支付失败）
5. **支付记录管理**：记录每次支付操作的详细信息
6. **支付成功通知**：发送支付成功消息到消息队列

#### 3.1.2 构件功能

**核心功能**：
- **UC10订单支付**：
  - 查询订单信息
  - 创建支付订单
  - 生成支付流水号
  - 调用第三方支付网关
  - 返回支付URL或二维码

- **支付回调处理**：
  - 验证回调签名
  - 更新支付订单状态
  - 发送支付成功消息到RabbitMQ
  - 生成支付记录

- **支付失败处理**：
  - 更新支付订单状态为失败
  - 取消订单
  - 释放库存
  - 生成支付记录

#### 3.1.3 构件依赖

**提供接口**：
- `POST /payments` - 创建支付订单
- `POST /payments/callback/alipay` - 支付宝回调
- `POST /payments/callback/wechat` - 微信支付回调
- `GET /payments/{paymentNumber}/status` - 查询支付状态
- `PaymentService.createPaymentOrder()` - 创建支付订单
- `PaymentCallbackHandler.handlePaymentSuccess()` - 处理支付成功

**需求接口**：
- `OrderService.getOrderDetail()` - 获取订单详情
- `OrderService.updateOrderStatus()` - 更新订单状态
- `OrderService.cancelOrder()` - 取消订单
- `InventoryService.deductStock()` - 扣减库存
- `InventoryService.releaseStock()` - 释放库存
- `AlipayGateway.processPayment()` - 调用支付宝支付
- `WechatGateway.processPayment()` - 调用微信支付
- `RabbitMQ.publish()` - 发布支付成功消息

#### 3.1.4 构件约束

**性能约束**：
日 + 6位序列号
- 支付金额精度：保留2位小数
- 支付回调必须验证签名
- 支付记录必须完整记录请求和响应参数

**技术约束**：
- 使用异步回调处理支付结果
- 使用消息队列解耦支付和订单服务
- 使用幂等性设计防止重复处理

### 3.2 支付构件内部类图

![支付构件内部类图](out/类图UML/PaymentComponent_ClassDiagram/PaymentComponent_ClassDiagram.png)

> **说明**：支付构件包含表示层（PaymentController）、业务逻辑层（PaymentService、PaymentCallbackHandler、PaymentGatewayFactory）、领域层（PaymentOrder、PaymentRecord）、数据访问层（PaymentOrderRepository、PaymentRecordRepository）、第三方支付网关（AlipayGateway、WechatGateway）以及消息队列发布器。

### 3.3 支付构件活动图

#### 3.3.1 处理支付活动图

![处理支付活动图](out/类图UML/PaymentComponent_ProcessPayment_Activity/PaymentComponent_ProcessPayment_Activity.png)

> **说明**：处理支付活动图展示了从接收支付请求、验证订单、创建支付订单、调用第三方支付网关到返回支付URL的完整流程，包含订单状态验证和支付方式选择。

#### 3.3.2 处理支付回调活动图

![处理支付回调活动图](out/类图UML/PaymentComponent_HandleCallback_Activity/PaymentComponent_HandleCallback_Activity.png)

> **说明**：处理支付回调活动图展示了从接收第三方支付回调、验证签名、更新支付订单状态、发布消息到RabbitMQ、生成支付记录的完整流程，包含支付成功和支付失败两种场景的处理。

### 3.4 支付构件接口详细描述

#### 3.4.1 表示层接口（PaymentController）

##### 接口1：创建支付订单

**接口名称**：`createPayment`

**接口类型**：REST API

**HTTP方法**：POST

**请求路径**：`/api/v1/payments`

**接口描述**：根据订单号创建支付订单，返回支付URL

**请求参数**：

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|-------|------|------|------|------|
| orderNumber | String | 是 | 订单号 | "ORD20251118001" |
| paymentMethod | String | 是 | 支付方式 | "ALIPAY"/"WECHAT" |

**请求示例**：

```json
POST /api/v1/payments
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "orderNumber": "ORD20251118001",
  "paymentMethod": "ALIPAY"
}
```

**响应参数**：

| 参数名 | 类型 | 说明 | 示例 |
|-------|------|------|------|
| code | Integer | 响应码 | 200 |
| message | String | 响应消息 | "支付订单创建成功" |
| data | Object | 支付数据 | {...} |
| data.paymentNumber | String | 支付流水号 | "PAY20251118000001" |
| data.amount | BigDecimal | 支付金额 | 707.00 |
| data.paymentUrl | String | 支付URL | "https://..." |
| data.qrCode | String | 支付二维码 | "data:image/png;base64,..." |
| data.expireTime | String | 过期时间 | "2025-11-18T14:45:00" |

**响应示例**：

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "code": 200,
  "message": "支付订单创建成功",
  "data": {
    "paymentNumber": "PAY20251118000001",
    "amount": 707.00,
    "paymentUrl": "https://openapi.alipay.com/gateway.do?...",
    "qrCode": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...",
    "expireTime": "2025-11-18T14:45:00"
  },
  "timestamp": 1700294400000
}
```

**异常响应**：

| HTTP状态码 | 错误码 | 错误消息 | 说明 |
|-----------|-------|---------|------|
| 404 | 404 | "订单不存在" | 订单号不存在 |
| 400 | 4003 | "订单状态不允许支付" | 订单不是待支付状态 |
| 400 | 4004 | "订单已过期" | 订单超过30分钟未支付 |
| 500 | 5002 | "支付网关调用失败" | 第三方支付接口异常 |

**接口约束**：
- 需要用户登录（JWT Token验证）
- 订单必须是待支付状态
- 订单未超过30分钟
- 同一订单不能重复创建支付订单

**处理流程**：
1. 验证JWT Token，获取用户信息
2. 验证请求参数（orderNumber、paymentMethod）
3. 调用PaymentService.createPaymentOrder()创建支付订单
4. 返回支付URL和二维码

---

##### 接口2：支付宝回调

**接口名称**：`alipayCallback`

**接口类型**：REST API

**HTTP方法**：POST

**请求路径**：`/api/v1/payments/callback/alipay`

**接口描述**：接收支付宝的异步回调通知

**请求参数**：

| 参数名 | 类型 | 必填 | 说明 |
|-------|------|------|------|
| out_trade_no | String | 是 | 商户订单号（支付流水号） |
| trade_no | String | 是 | 支付宝交易号 |
| trade_status | String | 是 | 交易状态 |
| total_amount | String | 是 | 订单金额 |
| gmt_payment | String | 是 | 支付时间 |
| sign | String | 是 | 签名 |

**请求示例**：

```
POST /api/v1/payments/callback/alipay
Content-Type: application/x-www-form-urlencoded

out_trade_no=PAY20251118000001&trade_no=2025111822001234567890&trade_status=TRADE_SUCCESS&total_amount=707.00&gmt_payment=2025-11-18+14:35:00&sign=...
```

**响应示例**：

```
success
```

**处理流程**：
1. 验证回调签名
2. 解析回调参数
3. 调用PaymentCallbackHandler.handleCallback()处理回调
4. 返回"success"给支付宝

---

##### 接口3：微信支付回调

**接口名称**：`wechatCallback`

**接口类型**：REST API

**HTTP方法**：POST

**请求路径**：`/api/v1/payments/callback/wechat`

**接口描述**：接收微信支付的异步回调通知

**请求参数**：XML格式

**响应示例**：

```xml
<xml>
  <return_code><![CDATA[SUCCESS]]></return_code>
  <return_msg><![CDATA[OK]]></return_msg>
</xml>
```

---

##### 接口4：查询支付状态

**接口名称**：`getPaymentStatus`

**接口类型**：REST API

**HTTP方法**：GET

**请求路径**：`/api/v1/payments/{paymentNumber}/status`

**接口描述**：查询支付订单的状态

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|-------|------|------|------|------|
| paymentNumber | String | 是 | 支付流水号 | "PAY20251118000001" |

**请求示例**：

```
GET /api/v1/payments/PAY20251118000001/status
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**响应参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| code | Integer | 响应码 |
| message | String | 响应消息 |
| data | Object | 支付状态数据 |
| data.paymentNumber | String | 支付流水号 |
| data.orderNumber | String | 订单号 |
| data.status | String | 支付状态 |
| data.amount | BigDecimal | 支付金额 |
| data.payTime | String | 支付时间 |

**响应示例**：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "paymentNumber": "PAY20251118000001",
    "orderNumber": "ORD20251118001",
    "status": "SUCCESS",
    "amount": 707.00,
    "payTime": "2025-11-18T14:35:00"
  }
}
```

---

#### 3.4.2 业务逻辑层接口（PaymentService）

##### 接口1：创建支付订单

**接口名称**：`createPaymentOrder`

**接口签名**：

```java
CreatePaymentResponse createPaymentOrder(CreatePaymentRequest request);
```

**接口描述**：创建支付订单并调用第三方支付网关

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| request | CreatePaymentRequest | 创建支付请求对象 |
| request.orderNumber | String | 订单号 |
| request.paymentMethod | PaymentMethod | 支付方式枚举 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| response | CreatePaymentResponse | 支付创建结果 |
| response.paymentNumber | String | 支付流水号 |
| response.amount | BigDecimal | 支付金额 |
| response.paymentUrl | String | 支付URL |
| response.qrCode | String | 支付二维码 |
| response.expireTime | LocalDateTime | 过期时间 |

**异常**：

| 异常类型 | 说明 | 处理方式 |
|---------|------|---------|
| OrderNotFoundException | 订单不存在 | 返回404错误 |
| OrderStatusException | 订单状态不允许支付 | 返回400错误 |
| OrderExpiredException | 订单已过期 | 返回400错误 |
| PaymentGatewayException | 支付网关调用失败 | 返回500错误 |

**处理流程**：

1. **查询订单信息**
   - 调用OrderService.getOrderDetail()获取订单详情
   - 验证订单是否存在
   - 验证订单状态是否为PENDING_PAYMENT
   - 验证订单是否过期

2. **创建支付订单实体**
   - 生成支付流水号（PAY + 年月日 + 7位序列号）
   - 设置支付状态为PENDING
   - 设置支付金额（从订单获取）
   - 设置支付方式
   - 设置过期时间（当前时间 + 15分钟）

3. **保存支付订单到数据库**
   - 保存PaymentOrder实体到payment_orders表

4. **调用第三方支付网关**
   - 根据支付方式选择支付网关（AlipayGateway或WechatGateway）
   - 调用支付网关的processPayment()方法
   - 获取支付URL和二维码

5. **返回支付创建结果**
   - 封装CreatePaymentResponse
   - 返回支付流水号、支付URL、二维码、过期时间

**事务管理**：
- 使用@Transactional注解开启本地事务
- 事务隔离级别：READ_COMMITTED
- 事务传播行为：REQUIRED

---

##### 接口2：查询支付状态

**接口名称**：`getPaymentStatus`

**接口签名**：

```java
PaymentStatusResponse getPaymentStatus(String paymentNumber);
```

**接口描述**：根据支付流水号查询支付状态

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| paymentNumber | String | 支付流水号 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| response | PaymentStatusResponse | 支付状态 |

**处理流程**：
1. 调用PaymentOrderRepository.findByPaymentNumber()查询支付订单
2. 如果支付订单不存在，抛出PaymentNotFoundException
3. 封装PaymentStatusResponse并返回

---

#### 3.4.3 业务逻辑层接口（PaymentCallbackHandler）

##### 接口1：处理支付回调

**接口名称**：`handleCallback`

**接口签名**：

```java
void handleCallback(PaymentCallbackRequest request);
```

**接口描述**：处理第三方支付的异步回调通知

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| request | PaymentCallbackRequest | 支付回调请求对象 |
| request.paymentNumber | String | 支付流水号 |
| request.tradeNo | String | 第三方交易号 |
| request.tradeStatus | String | 交易状态 |
| request.amount | BigDecimal | 支付金额 |
| request.payTime | LocalDateTime | 支付时间 |
| request.sign | String | 签名 |

**处理流程**：

1. **验证回调签名**
   - 使用支付网关的公钥验证签名
   - 如果签名验证失败，记录日志并返回

2. **查询支付订单**
   - 根据支付流水号查询支付订单
   - 如果支付订单不存在，记录日志并返回

3. **幂等性检查**
   - 检查支付订单状态
   - 如果已经是SUCCESS或FAILED状态，直接返回（防止重复处理）

4. **验证支付金额**
   - 比较回调金额与订单金额是否一致
   - 如果不一致，记录日志并返回

5. **更新支付订单状态**
   - 如果交易状态为成功，更新支付订单状态为SUCCESS
   - 如果交易状态为失败，更新支付订单状态为FAILED
   - 设置支付时间
   - 保存到数据库

6. **生成支付记录**
   - 创建PaymentRecord实体
   - 记录支付流水号、订单号、金额、状态、支付时间、交易详情
   - 保存到payment_records表

7. **处理支付成功**（如果支付成功）
   - 发布支付成功消息到RabbitMQ
   - 消息内容：paymentNumber、orderNumber、payTime
   - 交换机：payment.exchange
   - 路由键：payment.success

8. **处理支付失败**（如果支付失败）
   - 调用OrderService.cancelOrder()取消订单
   - 调用InventoryService.releaseStock()释放库存

**事务管理**：
- 使用@Transactional注解开启本地事务
- 事务隔离级别：READ_COMMITTED
- 事务传播行为：REQUIRED

**幂等性设计**：
- 使用支付订单状态判断是否已处理
- 使用数据库唯一索引防止重复插入支付记录

---

#### 3.4.4 数据访问层接口（PaymentOrderRepository）

##### 接口1：保存支付订单

**接口名称**：`save`

**接口签名**：

```java
PaymentOrder save(PaymentOrder paymentOrder);
```

**接口描述**：保存支付订单到数据库

**SQL语句**：

```sql
INSERT INTO payment_orders (
    payment_number, order_number, amount, payment_method,
    status, create_time, expire_time
) VALUES (?, ?, ?, ?, ?, ?, ?);
```

---

##### 接口2：根据支付流水号查询

**接口名称**：`findByPaymentNumber`

**接口签名**：

```java
PaymentOrder findByPaymentNumber(String paymentNumber);
```

**接口描述**：根据支付流水号查询支付订单

**SQL语句**：

```sql
SELECT * FROM payment_orders WHERE payment_number = ?;
```

**索引**：uk_payment_number（唯一索引）

---

##### 接口3：根据订单号查询

**接口名称**：`findByOrderNumber`

**接口签名**：

```java
PaymentOrder findByOrderNumber(String orderNumber);
```

**接口描述**：根据订单号查询支付订单

**SQL语句**：

```sql
SELECT * FROM payment_orders WHERE order_number = ?;
```

**索引**：idx_order_number

---

#### 3.4.5 数据访问层接口（PaymentRecordRepository）

##### 接口1：保存支付记录

**接口名称**：`save`

**接口签名**：

```java
PaymentRecord save(PaymentRecord paymentRecord);
```

**接口描述**：保存支付记录到数据库

**SQL语句**：

```sql
INSERT INTO payment_records (
    payment_number, order_number, user_id, amount,
    payment_method, status, pay_time, transaction_id,
    transaction_details, create_time
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
```

---

##### 接口2：根据支付流水号查询

**接口名称**：`findByPaymentNumber`

**接口签名**：

```java
List<PaymentRecord> findByPaymentNumber(String paymentNumber);
```

**接口描述**：根据支付流水号查询所有支付记录

**SQL语句**：

```sql
SELECT * FROM payment_records
WHERE payment_number = ?
ORDER BY create_time DESC;
```

**索引**：idx_payment_number

---

##### 接口3：根据订单号查询

**接口名称**：`findByOrderNumber`

**接口签名**：

```java
List<PaymentRecord> findByOrderNumber(String orderNumber);
```

**接口描述**：根据订单号查询所有支付记录

**SQL语句**：

```sql
SELECT * FROM payment_records
WHERE order_number = ?
ORDER BY create_time DESC;
```

**索引**：idx_order_number

---

## 4. 库存构件设计

### 4.1 库存构件文字描述

#### 4.1.1 构件职责

库存构件（Inventory Component）是库存管理的核心构件，负责处理商品库存的校验、锁定、扣减和释放。

**主要职责**：
1. **库存校验**：检查商品是否有足够的可用库存
2. **库存锁定**：创建订单时预扣库存（availableStock减少，lockedStock增加）
3. **库存扣减**：支付成功后实际扣减库存（lockedStock减少，totalStock减少）
4. **库存释放**：支付失败或订单取消时释放锁定的库存（lockedStock减少，availableStock增加）
5. **库存锁记录管理**：记录每次库存锁定操作的详细信息

#### 4.1.2 构件功能

**核心功能**：
- **批量校验库存**：
  - 遍历商品列表
  - 查询每个商品的库存信息
  - 检查可用库存是否充足
  - 返回校验结果

- **锁定库存（预扣库存）**：
  - 使用FOR UPDATE行锁查询库存
  - 使用乐观锁更新库存（version字段）
  - 创建库存锁记录
  - 如果锁定失败，回滚已锁定的库存

- **扣减库存（实际扣减）**：
  - 根据订单号查询库存锁记录
  - 扣减总库存和锁定库存
  - 更新库存锁状态为DEDUCTED

- **释放库存**：
  - 根据订单号查询库存锁记录
  - 释放锁定库存到可用库存
  - 更新库存锁状态为RELEASED

#### 4.1.3 构件依赖

**提供接口**：
- `InventoryService.batchCheckStock()` - 批量校验库存
- `InventoryService.lockStock()` - 锁定库存
- `InventoryService.deductStock()` - 扣减库存
- `InventoryService.releaseStock()` - 释放库存

**需求接口**：
- 无（库存构件不依赖其他业务构件）

#### 4.1.4 构件约束

**性能约束**：
- 库存校验响应时间 < 100ms（P95）
- 库存锁定响应时间 < 200ms（P95）
- 支持高并发库存操作 QPS ≥ 5000

**业务约束**：
- 使用乐观锁防止库存超卖
- 库存锁定失败时必须回滚
- 库存数量不能为负数
- 库存锁记录必须完整

**技术约束**：
- 使用数据库行锁（FOR UPDATE）保证并发安全
- 使用乐观锁（version字段）防止超卖
- 使用事务保证库存操作的原子性

### 4.2 库存构件内部类图

![库存构件内部类图](out/类图UML/InventoryComponent_ClassDiagram/InventoryComponent_ClassDiagram.png)

> **说明**：库存构件包含业务逻辑层（InventoryService）、领域层（Inventory、InventoryLock、各种Result对象）、数据访问层（InventoryRepository、InventoryLockRepository）。库存构件相对简单，不包含表示层（由订单服务调用），也不依赖其他业务构件。

### 4.3 库存构件活动图

#### 4.3.1 锁定库存活动图

![锁定库存活动图](out/类图UML/InventoryComponent_LockStock_Activity/InventoryComponent_LockStock_Activity.png)

> **说明**：锁定库存活动图展示了从接收锁定请求、遍历商品列表、查询库存、使用乐观锁更新库存、创建库存锁记录到返回结果的完整流程，包含库存不足、乐观锁冲突、锁定失败回滚等异常处理。

### 4.4 库存构件接口详细描述

#### 4.4.1 业务逻辑层接口（InventoryService）

##### 接口1：批量校验库存

**接口名称**：`batchCheckStock`

**接口签名**：

```java
StockCheckResult batchCheckStock(List<ProductQuantity> productList);
```

**接口描述**：批量校验商品库存是否充足

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| productList | List<ProductQuantity> | 商品列表 |
| productList[].productId | Long | 商品ID |
| productList[].quantity | Integer | 需要的数量 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| result | StockCheckResult | 库存校验结果 |
| result.success | boolean | 是否全部充足 |
| result.insufficientProducts | List | 库存不足的商品列表 |

**处理流程**：
1. 遍历商品列表
2. 查询每个商品的库存信息
3. 检查availableStock >= quantity
4. 如果有商品库存不足，记录到insufficientProducts
5. 返回校验结果

---

##### 接口2：锁定库存

**接口名称**：`lockStock`

**接口签名**：

```java
StockLockResult lockStock(String orderNumber, List<ProductQuantity> productList);
```

**接口描述**：锁定库存（预扣库存），用于创建订单时

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |
| productList | List<ProductQuantity> | 商品列表 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| result | StockLockResult | 库存锁定结果 |
| result.success | boolean | 是否全部锁定成功 |
| result.lockedProducts | List | 已锁定的商品列表 |
| result.failedProducts | List | 锁定失败的商品列表 |

**处理流程**：
1. 遍历商品列表
2. 使用FOR UPDATE查询库存（行锁）
3. 检查availableStock >= quantity
4. 使用乐观锁更新库存：
   - availableStock -= quantity
   - lockedStock += quantity
   - version += 1
5. 创建InventoryLock记录
6. 如果任何商品锁定失败，回滚所有已锁定的库存
7. 返回锁定结果

**异常处理**：
- 如果乐观锁冲突（version不匹配），返回失败
- 如果库存不足，返回失败
- 如果锁定失败，回滚所有已锁定的库存

---

##### 接口3：扣减库存

**接口名称**：`deductStock`

**接口签名**：

```java
StockDeductResult deductStock(String orderNumber);
```

**接口描述**：扣减库存（实际扣减），用于支付成功后

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| result | StockDeductResult | 库存扣减结果 |
| result.success | boolean | 是否全部扣减成功 |
| result.deductedProducts | List | 已扣减的商品列表 |

**处理流程**：
1. 根据订单号查询库存锁记录
2. 遍历库存锁记录
3. 更新库存：
   - totalStock -= lockedQuantity
   - lockedStock -= lockedQuantity
4. 更新库存锁状态为DEDUCTED
5. 返回扣减结果

---

##### 接口4：释放库存

**接口名称**：`releaseStock`

**接口签名**：

```java
StockReleaseResult releaseStock(String orderNumber);
```

**接口描述**：释放库存，用于支付失败或订单取消时

**输入参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| orderNumber | String | 订单号 |

**输出参数**：

| 参数名 | 类型 | 说明 |
|-------|------|------|
| result | StockReleaseResult | 库存释放结果 |
| result.success | boolean | 是否全部释放成功 |
| result.releasedProducts | List | 已释放的商品列表 |

**处理流程**：
1. 根据订单号查询库存锁记录
2. 遍历库存锁记录
3. 更新库存：
   - availableStock += lockedQuantity
   - lockedStock -= lockedQuantity
4. 更新库存锁状态为RELEASED
5. 返回释放结果

---

#### 4.4.2 数据访问层接口（InventoryRepository）

##### 接口1：根据商品ID查询库存

**接口名称**：`findByProductId`

**接口签名**：

```java
Inventory findByProductId(Long productId);
```

**接口描述**：根据商品ID查询库存信息

**SQL语句**：

```sql
SELECT * FROM inventory WHERE product_id = ?;
```

**索引**：uk_product_id（唯一索引）

---

##### 接口2：使用乐观锁更新库存

**接口名称**：`updateWithOptimisticLock`

**接口签名**：

```java
int updateWithOptimisticLock(Inventory inventory);
```

**接口描述**：使用乐观锁更新库存，防止并发冲突

**SQL语句**：

```sql
UPDATE inventory SET
    total_stock = ?,
    available_stock = ?,
    locked_stock = ?,
    version = version + 1,
    update_time = NOW()
WHERE product_id = ?
AND version = ?;
```

**返回值**：影响的行数（0表示版本冲突，1表示更新成功）

---

## 5. 构件设计总结

### 5.1 设计完整性

本文档完整设计了订单支付系统的三个核心构件：

1. ✅ **订单构件**：包含文字描述、内部类图、活动图、接口详细描述
2. ✅ **支付构件**：包含文字描述、内部类图、活动图、接口详细描述
3. ✅ **库存构件**：包含文字描述、内部类图、活动图、接口详细描述

### 5.2 设计特点

**分层架构**：
- 表示层：REST API接口
- 业务逻辑层：核心业务逻辑
- 领域层：实体类和值对象
- 数据访问层：Repository模式

**活动图替代伪代码**：
- 使用UML活动图清晰展示处理流程
- 包含判断分支、循环、异常处理
- 标注关键SQL语句和业务规则

**接口详细描述**：
- 接口签名、输入输出参数
- 异常类型和处理方式
- 处理流程步骤说明
- SQL语句和索引设计

### 5.3 设计原则

1. **单一职责原则**：每个构件专注于一个业务领域
2. **高内聚低耦合**：构件内部高内聚，构件之间低耦合
3. **依赖倒置原则**：依赖抽象接口而非具体实现
4. **接口隔离原则**：接口设计精简，职责明确
5. **开闭原则**：对扩展开放，对修改关闭

### 5.4 技术亮点

1. **分布式事务**：使用Seata保证订单和库存的一致性
2. **乐观锁**：使用version字段防止库存超卖
3. **消息队列**：使用RabbitMQ解耦支付和订单服务
4. **幂等性设计**：支付回调和消息消费都支持幂等性
5. **异步处理**：支付回调异步处理，提高系统吞吐量

---

## 附录：UML图生成说明

所有UML图使用PlantUML工具生成，源文件位于`类图UML/`目录：

- 订单构件内部类图：`OrderComponent_ClassDiagram.puml`
- 订单构件活动图：`OrderComponent_CreateOrder_Activity.puml`、`OrderComponent_HandlePaymentSuccess_Activity.puml`
- 支付构件内部类图：`PaymentComponent_ClassDiagram.puml`
- 支付构件活动图：`PaymentComponent_ProcessPayment_Activity.puml`、`PaymentComponent_HandleCallback_Activity.puml`
- 库存构件内部类图：`InventoryComponent_ClassDiagram.puml`
- 库存构件活动图：`InventoryComponent_LockStock_Activity.puml`

生成的PNG图片位于`out/类图UML/`目录。
- 支付订单创建响应时间 < 500ms（P95）
- 支付回调处理响应时间 < 200ms（P95）
- 支持并发支付 QPS ≥ 2000

**业务约束**：
- 支付超时时间：15分钟
- 支付流水号生成规则：PAY + 年月