
# 体系结构决策描述文档
## 云原生微服务电商平台 - 订单服务与支付服务

**项目名称**：云原生微服务电商平台
**当前迭代**：第一迭代（敏捷开发）
**核心用例**：UC9（创建订单）、UC10（订单支付）
**关注服务**：订单服务（Order Service）、支付服务（Payment Service）
**文档版本**：V1.0
**编写日期**：2025-11-18
**编写团队**：架构设计团队

---

## 一、体系结构决策概述

本文档记录了云原生微服务电商平台**第一迭代**的关键体系结构决策。基于敏捷开发方法，当前迭代聚焦于**UC9（创建订单）**和**UC10（订单支付）**两个核心用例，因此本文档主要关注**订单服务**和**支付服务**的架构决策。

每个决策都基于前期需求分析（5.UC9&UC10详细需求分析文档）、场景建模（6.1场景建模文档）、类图设计（6.2类图设计）和CRC卡设计（6.3CRC卡设计文档）的结果。

---

## 二、体系结构决策记录

### 决策1：订单服务和支付服务采用DDD四层架构风格

**设计问题**：订单服务和支付服务内部应该采用什么架构风格来组织代码？

**解决方案**：采用领域驱动设计（DDD）四层架构，将服务内部划分为接口层（Interfaces）、应用层（Application）、领域层（Domain）、基础设施层（Infrastructure）四层。

**分类**：架构风格决策

**假设**：
- 订单和支付是复杂的业务领域，需要清晰的领域模型
- 需要将业务逻辑与技术实现分离
- 团队需要学习DDD架构模式
- 便于领域模型的演进和维护

**约束**：
- 领域层是核心，不依赖任何其他层
- 应用层协调领域对象完成用例
- 基础设施层提供技术实现（数据库、消息队列等）
- 接口层处理外部请求（HTTP、消息等）

**备选方案**：
1. **DDD四层架构（接口层、应用层、领域层、基础设施层）**：适合复杂业务，领域模型清晰（选择此方案）
2. **三层架构（表示层、业务层、数据层）**：经典MVC模式，简单但领域逻辑分散
3. **六边形架构（端口适配器）**：更灵活但学习成本更高

**争论**：DDD四层架构学习成本较高，但对于电商这种复杂业务领域更合适。

**意义**：
- 领域模型清晰，业务逻辑集中在领域层
- 技术实现与业务逻辑分离，便于技术栈替换
- 符合微软eShop参考项目的架构风格
- 便于团队理解和维护复杂业务逻辑

**解决方案会在某种程度上的设计计吗**：是的，DDD架构增加了代码量和学习成本，但对于复杂业务领域是值得的。

**相关决策**：决策2（领域模型设计）、决策4（限界上下文划分）

**工作产品**：
- DDD分层说明（见2.需求调研文档.md）
- 类的属性和操作定义（见6.2.1类的属性和操作定义.md）

**计释**：
- **订单服务（Order Service）DDD四层架构**：
  - **接口层（Interfaces Layer）**：OrderController - 处理HTTP请求，参数验证，DTO转换
  - **应用层（Application Layer）**：OrderApplicationService - 用例编排，事务管理，调用领域服务
  - **领域层（Domain Layer）**：Order（聚合根）、OrderItem（实体）、OrderStatus（值对象）、OrderDomainService（领域服务）、OrderRepository（仓储接口）
  - **基础设施层（Infrastructure Layer）**：OrderRepositoryImpl（仓储实现）、OrderMapper（MyBatis映射）、消息发送实现
  
- **支付服务（Payment Service）DDD四层架构**：
  - **接口层（Interfaces Layer）**：PaymentController - 处理HTTP请求，PaymentCallbackHandler - 处理支付回调
  - **应用层（Application Layer）**：PaymentApplicationService - 用例编排，事务管理
  - **领域层（Domain Layer）**：PaymentOrder（聚合根）、PaymentRecord（实体）、PaymentStatus/PaymentMethod（值对象）、PaymentDomainService（领域服务）、PaymentRepository（仓储接口）
  - **基础设施层（Infrastructure Layer）**：PaymentRepositoryImpl（仓储实现）、PaymentMapper（MyBatis映射）、第三方支付网关适配器

**DDD四层架构包结构**：
```
com.ecommerce.order/
├── interfaces/          # 接口层
│   ├── controller/      # REST控制器
│   ├── dto/             # 数据传输对象
│   └── assembler/       # DTO与领域对象转换器
├── application/         # 应用层
│   ├── service/         # 应用服务
│   └── event/           # 应用事件处理
├── domain/              # 领域层（核心）
│   ├── model/           # 领域模型
│   │   ├── aggregate/   # 聚合根
│   │   ├── entity/      # 实体
│   │   └── valueobject/ # 值对象
│   ├── service/         # 领域服务
│   ├── repository/      # 仓储接口
│   └── event/           # 领域事件
└── infrastructure/      # 基础设施层
    ├── repository/      # 仓储实现
    ├── mapper/          # MyBatis映射
    ├── config/          # 配置类
    └── gateway/         # 外部服务网关
```

---

### 决策2：接口层采用RESTful API设计

**设计问题**：接口层如何组织代码以处理HTTP请求和响应？

**解决方案**：采用RESTful API设计风格，使用Spring MVC框架实现，接口层负责DTO与领域对象的转换。

**分类**：设计模式决策

**假设**：
- 前后端分离，后端只提供RESTful API
- 不需要服务端渲染视图
- 使用JSON作为数据交换格式

**约束**：
- Controller只负责请求处理和响应，不包含业务逻辑
- 使用DTO（数据传输对象）与外部交互
- 使用Assembler进行DTO与领域对象的转换
- 领域对象不直接暴露给外部

**备选方案**：
1. **RESTful API + DTO**：Controller + DTO + Assembler（选择此方案）
2. **GraphQL**：灵活但学习成本高
3. **gRPC**：性能好但不适合Web前端

**争论**：是否需要Assembler层进行对象转换。

**意义**：
- 符合RESTful API设计规范
- 领域模型与外部接口解耦
- 便于API测试和文档生成（Swagger）
- 保护领域模型不被外部直接访问

**解决方案会在某种程度上的设计计吗**：否，RESTful API是标准做法。

**相关决策**：决策1（DDD四层架构）、决策3（微服务架构）

**工作产品**：
- UC9订单创建流程（见6.1场景建模文档.md第59-108行）
- UC10支付流程（见6.1场景建模文档.md第117-182行）

**计释**：
- **订单服务接口层组件**：
  - **Controller**：OrderController - @RestController注解，处理/api/v1/orders路径
  - **DTO**：CreateOrderRequest、CreateOrderRspVO、OrderDetailRspVO
  - **Assembler**：OrderAssembler - 负责Order领域对象与DTO的相互转换
  
- **支付服务接口层组件**：
  - **Controller**：PaymentController - @RestController注解，处理/api/v1/payments路径
  - **DTO**：CreatePaymentRequest、PaymentRspVO
  - **Assembler**：PaymentAssembler - 负责PaymentOrder领域对象与DTO的相互转换

- **统一响应格式**：
```json
{
  "code": 200,
  "message": "success",
  "data": { ... }
}
```

---

### 决策3：订单服务和支付服务采用微服务架构

**设计问题**：UC9（创建订单）和UC10（订单支付）如何设计架构以支持独立部署和故障隔离？

**解决方案**：将订单功能和支付功能拆分为两个独立的微服务：订单服务（Order Service）和支付服务（Payment Service）。

**分类**：架构风格决策

**假设**：
- 订单和支付是两个独立的业务领域
- 支付服务可能需要对接多个第三方支付平台
- 订单服务和支付服务需要独立扩展
- 当前迭代聚焦这两个核心服务

**约束**：
- 两个服务间需要通过API通信
- 需要处理分布式事务（订单创建和支付）
- 每个服务拥有独立的数据库
- 服务间调用延迟需控制在500ms以内

**备选方案**：
1. **单体架构**：订单和支付在一个服务中，简单但无法独立扩展
2. **微服务架构**：订单和支付分离为两个服务（选择此方案）

**争论**：是否在第一迭代就拆分为微服务，还是先用单体架构快速验证。

**意义**：
- 订单服务和支付服务可以独立部署和扩展
- 支付服务故障不影响订单查询功能
- 便于后续对接多个支付渠道
- 符合单一职责原则

**解决方案会在某种程度上的设计计吗**：是的，微服务架构增加了服务间通信和分布式事务的复杂度。

**相关决策**：决策4（服务职责划分）、决策5（服务间通信）

**工作产品**：
- UC9&UC10场景建模（见6.1场景建模文档.md）
- 订单服务和支付服务类图（见6.2类图设计.md第262-294行）
- CRC卡设计（见6.3UC9&UC10_CRC卡设计文档.md）

**计释**：
- **订单服务（Order Service）**：负责Order、OrderItem、OrderStatus、OrderService类，端口8083
- **支付服务（Payment Service）**：负责PaymentOrder、PaymentRecord、PaymentStatus、PaymentMethod、PaymentService、PaymentCallbackHandler类，端口8084

---

### 决策4：基于DDD的服务职责划分

**设计问题**：订单服务和支付服务各自负责哪些类和职责？

**解决方案**：基于领域驱动设计（DDD），明确订单服务和支付服务的职责边界。

**分类**：服务职责决策

**假设**：
- 订单和支付是两个独立的限界上下文（Bounded Context）
- 每个服务拥有独立的领域模型
- 服务间通过领域事件通信

**约束**：
- 订单服务不能直接访问支付服务的数据库
- 支付服务不能直接访问订单服务的数据库
- 跨服务的数据访问必须通过API

**备选方案**：
1. **严格DDD划分**：订单和支付完全独立（选择此方案）
2. **共享数据库**：两个服务共享部分表，简化但增加耦合

**争论**：PaymentOrder是否应该属于订单服务。

**意义**：
- 清晰的职责边界
- 降低服务间耦合
- 便于独立演进

**解决方案会在某种程度上的设计计吗**：是的，需要处理跨服务的数据一致性。

**相关决策**：决策3（微服务架构）、决策7（分布式事务）

**工作产品**：
- 类的分析文档（见6.1.1类的分析.md第249-280行）
- 微服务架构映射（见6.2类图设计.md第262-294行）

**计释**：
- **订单服务职责**：
  - 实体类：Order、OrderItem
  - 枚举类：OrderStatus
  - 控制类：OrderService
  - 数据库：order_db
  
- **支付服务职责**：
  - 实体类：PaymentOrder、PaymentRecord
  - 枚举类：PaymentStatus、PaymentMethod
  - 控制类：PaymentService、PaymentCallbackHandler
  - 数据库：payment_db

---

### 决策5：订单服务和支付服务间采用RESTful API通信

**设计问题**：订单服务和支付服务之间如何进行同步通信？

**解决方案**：使用RESTful API + OpenFeign进行服务间HTTP调用。

**分类**：服务间通信决策

**假设**：
- 支付服务需要调用订单服务查询订单信息
- 订单服务需要调用支付服务创建支付订单
- 服务间通信延迟可接受（<500ms）

**约束**：
- 必须通过服务名调用（order-service、payment-service）
- 需要Nacos服务注册与发现支持
- 需要统一的错误处理和超时机制
- 调用超时时间设置为3秒

**备选方案**：
1. **RESTful API + OpenFeign**：简单易用，支持负载均衡（选择此方案）
2. **gRPC**：性能更好但学习成本高
3. **Dubbo**：功能强大但过于重量级

**争论**：是否使用gRPC以获得更好的性能。

**意义**：
- 简单易用，团队熟悉度高
- 支持Spring Cloud生态
- 便于调试和测试

**解决方案会在某种程度上的设计计吗**：是的，HTTP通信性能略低于RPC，但对本项目影响不大。

**相关决策**：决策6（异步通信）、决策7（分布式事务）、决策8（最终一致性）

**工作产品**：
- UC9订单创建流程（见6.1场景建模文档.md第59-108行）
- UC10支付流程（见6.1场景建模文档.md第117-182行）
- PaymentService依赖OrderService（见6.3UC9&UC10_CRC卡设计文档.md第468-495行）

**计释**：
- 支付服务调用订单服务：`GET /orders/{orderNumber}` 查询订单信息
- 订单服务调用支付服务：`POST /payments` 创建支付订单（可选，也可由前端直接调用）

---

### 决策6：支付回调使用消息队列实现异步处理

**设计问题**：支付成功后如何异步更新订单状态、扣减库存、清空购物车？

**解决方案**：使用RabbitMQ消息队列，支付服务发送支付成功消息，订单服务等消费消息进行后续处理。

**分类**：异步通信决策

**假设**：
- 支付成功后的操作（更新订单、扣减库存、清空购物车）可以异步处理
- 需要解耦支付服务和订单服务的强依赖
- 需要保证消息可靠传递

**约束**：
- 消息必须支持持久化（防止消息丢失）
- 需要实现消息重试机制（最多5次）
- 需要处理消息幂等性（防止重复消费）
- 消息格式：JSON，包含paymentNumber、orderNumber、status、payTime

**备选方案**：
1. **RabbitMQ**：功能完善，易用性好（选择此方案）
2. **Kafka**：高吞吐量但过于重量级
3. **RocketMQ**：功能强大但学习成本高

**争论**：是否在第一迭代就引入消息队列，还是先用同步调用。

**意义**：
- 解耦支付服务和订单服务
- 支付响应更快（不需要等待后续操作完成）
- 实现最终一致性
- 支付服务故障不影响订单服务

**解决方案会在某种程度上的设计计吗**：是的，增加了消息处理的复杂度，需要处理消息丢失、重复消费等问题。

**相关决策**：决策7（分布式事务）、决策8（最终一致性）

**工作产品**：
- UC10支付回调处理（见6.1场景建模文档.md第130-137行）
- PaymentCallbackHandler职责（见6.3UC9&UC10_CRC卡设计文档.md第499-528行）

**计释**：
- 交换机：payment.exchange（Topic类型）
- 队列：order.payment.success.queue
- 路由键：payment.success
- 消息体示例：
```json
{
  "paymentNumber": "PAY20251118001",
  "orderNumber": "ORD20251118001",
  "status": "SUCCESS",
  "payTime": "2025-11-18T14:30:00",
  "amount": 299.00
}
```

---

### 决策7：UC9订单创建采用Seata AT模式协调分布式事务

**设计问题**：UC9订单创建时，订单服务需要调用外部服务（商品服务的库存预扣、购物车服务的状态标记），如何保证数据一致性？

**解决方案**：订单服务作为事务发起方，使用Seata AT模式协调分布式事务，确保订单创建和外部服务调用的原子性。

**分类**：分布式事务决策

**假设**：
- UC9订单创建需要强一致性（订单创建和外部服务调用必须同时成功或失败）
- 商品服务和购物车服务提供支持Seata的接口
- 可以接受一定的性能开销（约200ms）
- MySQL数据库支持本地事务和undo_log

**约束**：
- 全局事务超时时间30秒
- 订单服务的order_db需要创建undo_log表
- 失败时需要自动回滚订单服务的本地操作
- Seata Server需要高可用部署

**备选方案**：
1. **Seata AT模式**：自动补偿，易用性好（选择此方案）
2. **最终一致性（消息队列）**：性能好但订单创建时一致性要求高
3. **TCC模式**：性能好但开发成本高，需要编写Try、Confirm、Cancel方法
4. **本地事务+补偿**：简单但需要手动处理失败场景

**争论**：订单创建是否可以使用最终一致性，还是必须使用强一致性。

**意义**：
- 保证UC9订单创建的强一致性
- 订单服务自动处理事务回滚（如外部服务调用失败，本地订单记录自动回滚）
- 降低开发复杂度，无需手动编写补偿逻辑

**解决方案会在某种程度上的设计计吗**：是的，Seata会增加约200ms的性能开销，需要额外的Seata Server组件，且依赖外部服务支持Seata。

**相关决策**：决策4（服务职责）、决策5（服务间通信）、决策6（异步通信）、决策8（最终一致性）

**工作产品**：
- UC9订单创建流程（见6.1场景建模文档.md第59-108行）
- 分布式事务协调服务（见5.UC9&UC10详细需求分析文档.md第222-224行）

**计释**：
- **订单服务职责**：
  1. 作为全局事务发起方（TM - Transaction Manager）
  2. 在OrderService.createOrder()方法添加@GlobalTransactional注解
  3. 创建Order和OrderItem记录（本地事务）
  4. 调用商品服务的库存预扣接口（通过OpenFeign）
  5. 调用购物车服务的状态标记接口（通过OpenFeign）
  
- **外部服务依赖**：
  - 商品服务：提供库存预扣接口，支持Seata分支事务
  - 购物车服务：提供状态标记接口，支持Seata分支事务
  
- **回滚场景**：
  - 如果订单创建失败：无需回滚外部服务
  - 如果外部服务调用失败：Seata自动回滚订单服务的本地事务
  - 如果网络超时：Seata根据超时策略决定回滚或重试

---

### 决策8：UC10支付成功后采用消息队列实现最终一致性

**设计问题**：UC10支付成功后，支付服务需要通知订单服务更新状态，同时订单服务需要通知其他服务（商品服务扣减库存、购物车服务清空购物车），如何设计这个通知机制？

**解决方案**：支付服务通过RabbitMQ发送支付成功消息，订单服务消费消息后更新本地订单状态，并通过消息或API调用通知其他外部服务。

**分类**：异步通信与最终一致性决策

**假设**：
- 支付成功后的操作可以异步处理
- 可以接受短暂的数据不一致（最终会一致）
- 消息队列保证消息可靠传递
- 外部服务（商品服务、购物车服务）提供相应的接口

**约束**：
- 消息必须持久化（防止消息丢失）
- 需要实现消息重试（最多5次）
- 需要处理幂等性（防止重复处理）
- 失败的消息进入死信队列，人工处理
- 消息格式：JSON，包含paymentNumber、orderNumber、status、payTime

**备选方案**：
1. **最终一致性（消息队列）**：性能好，符合支付场景（选择此方案）
2. **Seata AT模式**：强一致但性能开销大，支付场景不需要
3. **同步调用**：简单但性能差，支付响应慢，且耦合度高

**争论**：支付成功后是否需要强一致性，还是最终一致性即可。

**意义**：
- 支付响应更快（不需要等待后续操作完成）
- 降低支付服务和订单服务的耦合
- 提升系统吞吐量
- 支付服务故障不影响订单服务

**解决方案会在某种程度上的设计计吗**：是的，需要处理消息丢失、重复消费、补偿等问题，增加了系统复杂度。

**相关决策**：决策6（消息队列）、决策7（UC9分布式事务）

**工作产品**：
- UC10支付流程（见6.1场景建模文档.md第117-182行）
- PaymentCallbackHandler职责（见6.3UC9&UC10_CRC卡设计文档.md第499-528行）

**计释**：
- **支付服务职责**：
  1. 更新PaymentOrder状态为SUCCESS（本地事务）
  2. 发送payment.success消息到RabbitMQ
  3. 创建PaymentRecord记录
  
- **订单服务职责**：
  1. 消费payment.success消息
  2. 更新Order状态为PENDING_SHIPMENT（本地事务）
  3. 调用商品服务的库存扣减接口（通过OpenFeign或消息）
  4. 调用购物车服务的清空接口（通过OpenFeign或消息）
  
- **幂等性保证**：
  - 订单服务：使用paymentNumber作为幂等键，Redis记录已处理的消息
  - 外部服务：各自实现幂等性机制
  
- **失败处理**：
  - 消息消费失败：自动重试最多5次
  - 外部服务调用失败：记录失败日志，进入补偿流程
  - 死信队列：人工介入处理

---

### 决策9：订单服务和支付服务的数据持久化策略

**设计问题**：订单服务和支付服务如何进行数据持久化？

**解决方案**：使用MySQL作为关系型数据库，MyBatis-Plus作为ORM框架，每个服务拥有独立的数据库。

**分类**：数据存储决策

**假设**：
- 订单和支付数据结构相对稳定
- 需要ACID事务支持
- 团队熟悉MySQL和MyBatis

**约束**：
- 订单服务和支付服务必须有独立的数据库（order_db、payment_db）
- 不允许跨服务直接访问数据库
- 需要定期备份数据

**备选方案**：
1. **MySQL + MyBatis-Plus**：成熟稳定，团队熟悉（选择此方案）
2. **PostgreSQL + JPA**：功能更强但团队不熟悉
3. **MongoDB**：灵活但不适合强一致性场景

**争论**：是否使用JPA代替MyBatis。

**意义**：
- 保证数据一致性（ACID）
- 支持复杂查询
- 团队熟悉度高，开发效率高

**解决方案会在某种程度上的设计计吗**：是的，关系型数据库在高并发场景下可能成为瓶颈，但第一迭代可接受。

**相关决策**：决策2（服务职责划分）

**工作产品**：
- 技术选型表（见2.需求调研文档.md第50-59行）
- 数据模型（见2.需求调研文档.md第99-102行）

**计释**：
- **订单服务数据库（order_db）**：
  - 表：orders（订单表）、order_items（订单明细表）
  - ORM：MyBatis-Plus，使用BaseMapper接口
  - 事务：@Transactional注解，支持Seata分布式事务
  
- **支付服务数据库（payment_db）**：
  - 表：payment_orders（支付订单表）、payment_records（支付记录表）
  - ORM：MyBatis-Plus，使用BaseMapper接口
  - 事务：@Transactional注解

---

## 三、订单服务与支付服务架构决策总结

### 3.1 决策统计（第一迭代）

| 决策类别 | 决策数量 | 关键决策 |
|---------|---------|---------|
| 架构风格 | 3 | 微服务架构、DDD四层架构、RESTful API |
| 服务设计 | 2 | 服务职责划分、服务间通信 |
| 分布式一致性 | 3 | 异步通信、分布式事务（Seata）、最终一致性（MQ） |
| 数据存储 | 1 | MySQL + MyBatis-Plus |
| **总计** | **9** | - |

### 3.2 订单服务与支付服务技术栈

| 技术组件 | 选型 | 版本 | 用途 |
|---------|------|------|------|
| 开发语言 | Java | 17+ | 后端开发 |
| 微服务框架 | Spring Boot + Spring Cloud | 3.x + 2023.x | 微服务开发 |
| Web框架 | Spring MVC | - | RESTful API（DDD接口层） |
| 服务调用 | OpenFeign | - | 订单↔支付服务间通信 |
| 消息队列 | RabbitMQ | 3.x | 支付成功异步通知 |
| 分布式事务 | Seata AT | - | UC9订单创建事务一致性 |
| 数据库 | MySQL | 8.0 | order_db、payment_db |
| ORM框架 | MyBatis-Plus | 3.x | 数据持久化 |

### 3.3 UC9与UC10架构对比

| 用例 | 一致性策略 | 技术方案 | 响应时间 | 复杂度 |
|------|-----------|---------|---------|--------|
| **UC9创建订单** | 强一致性 | Seata AT两阶段提交 | 约2秒（含200ms事务开销） | 高 |
| **UC10订单支付** | 最终一致性 | RabbitMQ异步消息 | 约3秒（支付处理） | 中 |

### 3.4 架构质量属性（第一迭代目标）

| 质量属性 | 目标 | 实现方式 |
|---------|------|---------|
| **可扩展性** | 订单和支付服务独立扩展 | 微服务架构 + 独立数据库 |
| **可用性** | 单服务故障不影响另一服务 | 服务隔离 + 异步解耦 |
| **性能** | UC9<2秒，UC10<3秒 | Seata AT + RabbitMQ异步 |
| **一致性** | UC9强一致，UC10最终一致 | Seata + 消息队列 |
| **可维护性** | 代码清晰易懂 | DDD四层架构 + 领域模型设计 |

### 3.5 后续迭代规划

本文档聚焦第一迭代的订单服务和支付服务。后续迭代将逐步引入：
- **第二迭代**：用户服务、商品服务、购物车服务
- **第三迭代**：API网关、服务注册与发现（Nacos）
- **第四迭代**：监控、日志、链路追踪等可观测性组件
- **第五迭代**：Docker容器化、CI/CD流水线

---

**文档版本**：V1.0
**文档状态**：第一迭代架构决策已完成
**下一步工作**：基于本决策文档进行订单服务和支付服务的详细设计和编码实现
**文档结束**