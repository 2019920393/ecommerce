# 云原生微服务电商平台需求调研文档

## 一、项目背景与目标

### 1.1 项目背景
随着云计算和微服务架构的快速发展，传统单体架构的电商系统已经难以满足现代业务对高并发、高可用、弹性扩展的需求。云原生技术为电商平台提供了灵活、可扩展、易维护的解决方案。本项目旨在基于云原生和微服务架构，开发一个现代化的电商平台，学习和实践主流的分布式系统开发技术。

### 1.2 项目目标
- 掌握微服务架构设计思想和实践方法
- 学习领域驱动设计（DDD）在实际项目中的应用
- 实践云原生技术栈（Docker、Kubernetes、CI/CD）
- 理解分布式系统中的常见问题及解决方案
- 开发一个功能完整、架构清晰的电商平台原型系统

### 1.3 参考项目
本项目参考微软的 **eShop** 参考架构。eShop 是微软官方提供的.NET微服务架构示例项目，展示了如何使用现代化的架构模式和云原生技术构建电商应用。我们将借鉴其架构设计理念，使用 Java/Go 技术栈进行实现。

## 二、市场与技术调研

### 2.1 电商平台核心功能分析
通过对主流电商平台（淘宝、京东、拼多多等）的调研，电商系统的核心功能可归纳为以下几个模块：

**用户端功能：**
- **商品浏览与搜索**：用户可以按分类浏览商品，通过关键词搜索商品，查看商品详情（图片、价格、描述、库存、评价等）
- **购物车管理**：用户可以将感兴趣的商品加入购物车，调整商品数量，移除商品，实时查看购物车总价
- **订单管理**：用户可以从购物车生成订单，填写收货信息，选择配送方式，查看订单历史和物流状态
- **支付功能**：支持多种支付方式（支付宝、微信支付、银行卡等），提供支付状态实时反馈

**管理端功能：**
- **商品管理**：管理员可以添加、编辑、删除商品信息，管理商品分类和库存
- **订单管理**：管理员可以查看所有订单，处理订单状态（发货、取消、退款等）
- **用户管理**：管理用户信息，处理用户权限和账户问题

### 2.2 云原生与微服务技术调研

**微服务架构优势：**
- **独立部署**：每个服务可以独立开发、测试、部署，降低系统耦合度
- **技术异构**：不同服务可以使用不同技术栈，选择最适合的工具
- **故障隔离**：单个服务的故障不会影响整个系统
- **团队协作**：不同团队可以并行开发不同服务，提高开发效率

**云原生技术栈：**
- **容器化（Docker）**：将应用及其依赖打包成容器镜像，保证环境一致性
- **容器编排（Kubernetes）**：自动化容器的部署、扩展和管理
- **服务网格（可选）**：提供服务间通信、负载均衡、故障恢复等功能
- **持续集成/持续部署（CI/CD）**：自动化代码构建、测试、部署流程

**主流技术选型对比：**

| 技术组件 | 选项A | 选项B | 推荐 |
|---------|-------|-------|------|
| 开发语言 | Java (Spring Boot) | Go | Java（生态成熟）|
| 微服务框架 | Spring Cloud | Dubbo | Spring Cloud（功能全面）|
| 服务注册发现 | Nacos | Eureka | Nacos（配置+注册）|
| API网关 | Spring Cloud Gateway | Kong | Spring Cloud Gateway |
| 分布式事务 | Seata | 最终一致性 | Seata（AT模式）|
| 数据库 | MySQL | PostgreSQL | MySQL（熟悉度高）|
| 缓存 | Redis | - | Redis |
| 消息队列 | RabbitMQ | Kafka | RabbitMQ（易用性好）|

## 三、功能需求分析

### 3.1 用户服务（User Service）

**核心功能：**
- 用户注册：支持手机号/邮箱注册，验证码验证
- 用户登录：支持密码登录、第三方登录（可选）
- 用户信息管理：修改个人信息、头像、密码
- 收货地址管理：添加、编辑、删除收货地址，设置默认地址
- 权限管理：区分普通用户和管理员角色

**数据模型：**
- 用户表：用户ID、用户名、密码（加密）、手机号、邮箱、创建时间
- 地址表：地址ID、用户ID、收货人、联系电话、省市区、详细地址、是否默认

### 3.2 商品服务（Product Service）

**核心功能：**
- 商品分类管理：支持多级分类（一级分类、二级分类）
- 商品信息管理：商品的增删改查，包含商品名称、价格、库存、描述、图片等
- 商品搜索：支持关键词搜索，按价格、销量排序
- 商品详情展示：展示商品的详细信息和规格参数
- 库存管理：实时更新库存数量，库存预警

**数据模型：**
- 分类表：分类ID、分类名称、父分类ID、层级
- 商品表：商品ID、商品名称、分类ID、价格、库存、描述、主图URL、创建时间
- 商品图片表：图片ID、商品ID、图片URL

### 3.3 订单服务（Order Service）

**核心功能：**
- 购物车管理：添加/删除商品、修改数量、清空购物车
- 订单创建：从购物车生成订单，填写收货信息
- 订单支付：调用支付服务，更新订单支付状态
- 订单查询：查看订单列表、订单详情、订单状态（待支付、待发货、待收货、已完成、已取消）
- 订单取消：用户取消未支付订单，管理员取消/退款已支付订单

**数据模型：**
- 购物车表：购物车ID、用户ID、商品ID、数量、添加时间
- 订单表：订单ID、用户ID、订单号、总金额、收货信息、订单状态、创建时间、支付时间
- 订单明细表：明细ID、订单ID、商品ID、商品名称、价格、数量、小计

### 3.4 支付服务（Payment Service）（可简化实现）

**核心功能：**
- 支付接口集成：集成第三方支付平台（沙箱环境或模拟支付）
- 支付请求：生成支付订单，跳转支付页面
- 支付回调：接收支付平台回调，更新支付状态
- 支付查询：查询支付状态

**简化实现方案：**
由于是课程作业，可以实现一个模拟支付功能，无需真实接入支付宝/微信支付API，只需模拟支付流程和状态变更。

## 四、非功能需求

### 4.1 性能需求
- **响应时间**：页面加载时间 < 2秒，API响应时间 < 500ms
- **并发处理**：支持至少100个并发用户同时访问
- **数据库性能**：查询响应时间 < 100ms

### 4.2 可用性需求
- **系统可用性**：目标可用性 99%（允许少量停机时间用于学习部署）
- **故障恢复**：服务崩溃后能够自动重启
- **数据备份**：定期备份数据库数据

### 4.3 安全性需求
- **身份认证**：使用JWT Token进行用户身份验证
- **数据加密**：用户密码使用BCrypt加密存储
- **SQL注入防护**：使用参数化查询，防止SQL注入攻击
- **XSS防护**：前端对用户输入进行转义处理

### 4.4 可维护性需求
- **代码规范**：遵循Java/Go编码规范，使用统一的代码风格
- **文档完整**：提供API文档（Swagger）、部署文档、架构设计文档
- **日志记录**：记录关键操作日志，便于问题排查
- **监控告警**：提供基础的系统监控面板

### 4.5 可扩展性需求
- **水平扩展**：通过增加服务实例数量来提升系统处理能力
- **模块化设计**：新增功能时只需添加新的微服务，不影响现有服务

## 五、技术架构设计

### 5.1 系统架构图

**UML构件图**（标准UML 2.5格式）

![云原生电商平台系统架构构件图_带接口](out/UML/系统架构构件图_带接口_ComponentDiagram/云原生电商平台系统架构构件图_带接口.png)

> **PlantUML源文件**：`类图UML/系统架构构件图_ComponentDiagram.puml`  
>
> 图片文件：out/UML/系统架构构件图_带接口_ComponentDiagram/云原生电商平台系统架构构件图_带接口.png

**架构图说明**：
- **5层架构**：客户端层 → 网关层 → 微服务层 → 基础设施层 → 监控与日志层
- **4个微服务**：用户服务、商品服务、订单服务、支付服务
- **服务注册与发现**：所有服务注册到Nacos，API网关从Nacos发现服务
- **数据库隔离**：每个服务拥有独立的MySQL数据库
- **缓存策略**：每个服务使用Redis进行数据缓存（用户、商品、订单、购物车）
- **异步通信**：订单服务和支付服务通过RabbitMQ进行异步消息传递
- **服务间调用**：订单服务调用商品服务（库存检查），支付服务调用订单服务（状态更新）
- **监控体系**：Prometheus+Grafana（指标监控）、ELK Stack（日志收集）、Zipkin（链路追踪）

**架构层次说明**：

| 层次 | 组件 | 作用 | 技术栈 |
|-----|------|------|--------|
| **客户端层** | Web浏览器、移动应用 | 用户交互界面 | React/Vue |
| **网关层** | API Gateway | 统一入口、路由、鉴权、限流 | Spring Cloud Gateway |
| **微服务层** | 4个业务微服务 | 核心业务逻辑 | Spring Boot + Spring Cloud |
| **基础设施层** | Nacos、MySQL、Redis、RabbitMQ | 服务注册、数据存储、缓存、消息队列 | Nacos + MySQL + Redis + RabbitMQ |
| **监控日志层** | Prometheus、ELK、Zipkin | 系统监控、日志收集、链路追踪 | Prometheus + Grafana + ELK + Zipkin |

**微服务详细信息**：

| 微服务 | 端口 | 数据库 | 主要功能 | 依赖服务 |
|-------|------|--------|---------|---------|
| 用户服务 | 8081 | user_db | 注册、登录、信息管理、地址管理 | Nacos、MySQL、Redis |
| 商品服务 | 8082 | product_db | 商品管理、分类、搜索、库存 | Nacos、MySQL、Redis |
| 订单服务 | 8083 | order_db | 购物车、订单创建、查询、取消 | Nacos、MySQL、Redis、RabbitMQ、商品服务 |
| 支付服务 | 8084 | payment_db | 支付处理、支付查询、支付回调 | Nacos、MySQL、RabbitMQ、订单服务 |

**构件图关系说明**：

1. **依赖关系（Dependency）**：
   - 所有微服务依赖Nacos进行服务注册和配置管理
   - 所有微服务依赖监控组件（Prometheus、ELK、Zipkin）

2. **使用关系（Usage）**：
   - 客户端通过HTTPS访问API Gateway
   - API Gateway路由请求到各个微服务
   - 微服务通过OpenFeign进行服务间HTTP调用

3. **数据流向**：
   - 同步调用：客户端 → API Gateway → 微服务 → 数据库
   - 异步通信：订单服务/支付服务 → RabbitMQ → 消息消费

### 5.2 领域驱动设计（DDD）
每个微服务按照DDD的分层架构组织：
- **接口层（Interface）**：对外提供RESTful API，处理HTTP请求
- **应用层（Application）**：协调领域对象，处理业务流程
- **领域层（Domain）**：包含领域模型、实体、值对象、领域服务
- **基础设施层（Infrastructure）**：数据持久化、外部服务调用

### 5.3 服务拆分原则
- **单一职责原则**：每个服务只负责一个业务领域
- **高内聚低耦合**：服务内部功能高度相关，服务之间依赖最小化
- **独立数据库**：每个服务拥有独立的数据库，避免数据库层面的耦合

### 5.4 分布式事务处理
**场景：** 用户下单时需要：
1. 扣减商品库存（商品服务）
2. 创建订单（订单服务）
3. 清空购物车（订单服务）

**解决方案：**
- **方案A - Seata AT模式**：使用Seata提供的两阶段提交，保证事务一致性
- **方案B - 最终一致性**：使用消息队列（RabbitMQ）+ 本地事务表，通过异步补偿保证最终一致性

推荐使用**Seata AT模式**，学习两阶段提交的实现原理。

### 5.5 服务间通信
- **同步调用**：使用 OpenFeign 进行服务间的HTTP调用
- **异步通信**：使用 RabbitMQ 进行异步消息传递（如订单状态变更通知）

### 5.6 系统监控与日志
- **日志收集**：使用 ELK Stack（Elasticsearch + Logstash + Kibana）或简化方案（文件日志）
- **链路追踪**：使用 Spring Cloud Sleuth + Zipkin 进行分布式链路追踪
- **监控面板**：使用 Spring Boot Actuator + Prometheus + Grafana（可选）

## 六、部署架构

### 6.1 容器化方案
- 每个微服务打包成独立的Docker镜像
- 使用多阶段构建优化镜像大小
- 编写Dockerfile和docker-compose.yml

### 6.2 Docker-Compose部署
```yaml
services:
  - mysql（数据库）
  - redis（缓存）
  - rabbitmq（消息队列）
  - nacos（注册中心）
  - gateway（API网关）
  - user-service（用户服务）
  - product-service（商品服务）
  - order-service（订单服务）
  - payment-service（支付服务）
  - frontend（前端应用）
```

### 6.3 CI/CD流水线（可选进阶）
- **代码管理**：Git + GitHub/GitLab
- **持续集成**：Jenkins / GitHub Actions
- **自动化测试**：单元测试、集成测试
- **自动化部署**：构建Docker镜像 → 推送到镜像仓库 → 部署到服务器

## 七、技术选型总结

### 7.1 后端技术栈
- **开发语言**：Java 17+
- **微服务框架**：Spring Boot 3.x + Spring Cloud 2023.x
- **服务注册与发现**：Nacos 2.x
- **配置中心**：Nacos Config
- **API网关**：Spring Cloud Gateway
- **负载均衡**：Spring Cloud LoadBalancer
- **服务调用**：OpenFeign
- **分布式事务**：Seata
- **数据库**：MySQL 8.0
- **缓存**：Redis 7.x
- **消息队列**：RabbitMQ 3.x
- **ORM框架**：MyBatis-Plus / Spring Data JPA

### 7.2 前端技术栈
- **框架**：Vue 3 / React 18
- **UI组件库**：Element Plus / Ant Design
- **状态管理**：Pinia / Redux
- **HTTP客户端**：Axios
- **路由**：Vue Router / React Router

### 7.3 DevOps工具链
- **容器化**：Docker
- **容器编排**：Docker-Compose（学习阶段）/ Kubernetes（进阶）
- **CI/CD**：GitHub Actions / Jenkins
- **监控**：Spring Boot Actuator、Prometheus（可选）
- **日志**：Logback、ELK（可选）
- **链路追踪**：Zipkin（可选）

## 八、风险分析与应对措施

### 8.1 技术风险
**风险1：分布式系统复杂度高，学习曲线陡峭**
- 应对：先实现单体应用，逐步拆分为微服务；充分利用官方文档和示例代码

**风险2：分布式事务处理困难**
- 应对：先使用Seata的简单模式，如果遇到问题可降级为最终一致性方案

**风险3：Docker和Kubernetes学习成本高**
- 应对：先使用Docker-Compose完成基本部署，Kubernetes作为可选进阶内容

### 8.2 进度风险
**风险：功能较多，时间有限，可能无法按期完成**
- 应对：制定详细的开发计划，划分优先级（核心功能 > 辅助功能 > 可选功能）
- MVP（最小可行产品）：订单创建、支付

### 8.3 团队协作风险
**风险：分工不明确，代码冲突频繁**
- 应对：
  - 明确每个人的职责范围
  - 使用Git分支管理，制定代码提交规范
  - 定义统一的API接口规范，使用Swagger文档
  - 定期进行代码评审和联调测试

## 九、项目计划与里程碑

### 第一阶段：架构设计与环境搭建（1-2周）
- 完成详细的架构设计文档
- 搭建开发环境（JDK、Maven、Docker、MySQL、Redis等）
- 搭建微服务基础框架（Nacos、Gateway、配置中心）
- 定义统一的API规范和数据模型

### 第二阶段：核心功能开发（3-4周）
- 用户服务：注册、登录、信息管理
- 商品服务：商品管理、商品展示、搜索
- 订单服务：购物车、订单创建、订单查询
- 支付服务：模拟支付流程
- 前端开发：对应页面和交互功能

### 第三阶段：集成与测试（1-2周）
- 服务间联调测试
- 分布式事务测试
- 前后端集成测试
- 性能测试和优化

### 第四阶段：部署与文档（1周）
- Docker容器化所有服务
- 编写docker-compose.yml完成一键部署
- 编写部署文档和使用手册
- 准备项目演示PPT和视频

## 十、总结

本项目通过开发一个云原生微服务电商平台，将帮助团队成员深入理解和掌握微服务架构、领域驱动设计、容器化技术、分布式系统等核心概念。项目参考微软eShop的架构设计思想，结合实际的业务场景，实现商品展示、购物车、订单管理、支付集成等核心电商功能。

通过合理的技术选型、清晰的架构设计、明确的分工协作，本项目具有较高的可行性和学习价值。在开发过程中，团队需要注重代码质量、文档完整性和问题解决能力的培养，最终交付一个功能完整、架构清晰、可演示的电商平台系统。

